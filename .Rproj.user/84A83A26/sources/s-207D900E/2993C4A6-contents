---
title: "sqlite-R"
author: "Kyle W. Brown"
date: "10/26/2020"
toc: true
output:
  html_document:
    fig_caption: no
    theme: readable
    toc: yes
    toc_depth: 2
    toc_float:
      collapsed: yes
    include:
      after_body: footer.html
  pdf_document:
    toc: yes
    toc_depth: '2'
  word_document:
    toc: yes
    toc_depth: '2'
editor_options: 
  chunk_output_type: inline
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
library(RSQLite)
library(DBI)
library(kableExtra)
library(tidyverse)
```

<br>

# Intro

---

This document is meant as a way to convey intermediate to advanced SQL queries with sqlite directly with R.  

## DB Connection

```{r, echo=TRUE}
# Create an ephemeral in-memory RSQLite database
con <- dbConnect(RSQLite::SQLite(), "customers.sqlite")
```

## Alternate Connection

```r
library("RSQLite")

# connect to the sqlite file
sqlite    <- dbDriver("SQLite")
exampledb <- dbConnect(sqlite,"customers.sqlite")

dbListTables(exampledb)
```
<br>

## SQL

---

### SQL - Structured Query Language

SQL is a formal language for communicating with a database to articulate precisely what information you want from a collection of database tables.

SQL is one of the most commonly used languages in the world (currently the 9th most popular programming language according to [Code-dojo](https://www.codingdojo.com/blog/the-7-most-in-demand-programming-languages-of-2019)!).  You **will** be asked about it in a job interview if you're applying to be a Data Scientist or a Data Analyst.

Databases are *structured* repositories for data.  Having seen the `pandas` library, a table in SQL is very much analogous to a `DataFrame` in `pandas`.

 * A table has **typed columns**, in that each element in a specific column has the same data type.  
 * The **schema** of the database specifies the structure of the table, where each column has a **name** associated with it, and a specified **data type**.  
 * The entries are the **rows** in the table.  
 * A SQL database can consist of one or more tables.  

The goal of this notebook is to give you an introduction to SQL and the operations of selecting data in tables and basic operations that can be performed on the data, as well as the SQL commands to join two or more tables together.  Later notebooks will address more advanced details on SQL functions, as well as Python tools for using  SQL databases.

In this Jupyter notebook we will use the `sqlite` extension to perform SQL operations.  This extension is designed to interact with [SQLite](https://sqlite.org/index.html) databases.  We first load this extension and then connect to an existing database file that has two tables of interest to us in it. 


### Checking Tables in Connection

Check all the tables save in the same connection (directory)

```{r}
dbListTables(con)
```

<br>

### Data

There are two tables in this database, one called `customers` and the other is `adclicks`.  Suppose that we have been given this data from our marketing team, and we want to perform analysis on this information.  In particular, `customers` includes some basic demographic information about each customer, while `adclicks` includes information about advertisements that were served to the customers on websites they have visited, and whether or not a customer clicked on the advertisement or not.  

**We want to estimate the ad "click-through rate", to see if we can determine if the age of a customer, their location, and/or the website where they saw the advertisement has an effect on this ad click-through rate.**  

<br>

# Statements

## SELECT

---

With this ultimate goal in mind, let's first explore the basic SQL operations to view, manipulate, and aggregate data in these tables.

Selecting all columns with *

```{r}
customers_df <- dbGetQuery(con, "SELECT * FROM customers")
```

```{r, message=FALSE, warning=FALSE}
customers_df %>%
  kbl() %>%
  kable_classic(full_width = F, html_font = "Cambria")
```

<br>

### SELECT - getting information from Tables

One of the most basic operations in SQL is the `SELECT` command, to get data from a table.  Here's how we can use it.

We can immediately see that we don't necessarily want to get **all** the data from the table at once.  We can use the `LIMIT` command to display a smaller amount of the data in the query.  Often we use `LIMIT` because we just want to get a representative portion of the result to make sure it's what we expect to see.  It's especially important to use `LIMIT` when you're examining tables that are thousands or millions of rows long.  


```{r}
customers_df <- dbGetQuery(con, "SELECT * FROM customers LIMIT 10")
```

```{r, message=FALSE, warning=FALSE}
customers_df %>%
  kbl() %>%
  kable_classic(full_width = F, html_font = "Cambria")
```

<br>

We see that this `customers` table has four columns in it.  `userID` is an `INTEGER`, `name` and `zipCode` are stored as strings (or `TEXT` in SQL-speak), and `age` is an `INTEGER`.  We will see later how to inspect a table to determine this "schema", and how to create tables to store data.  

```{r}
customers_df <- dbGetQuery(con, "SELECT name, age FROM customers LIMIT 5")
```

```{r, message=FALSE, warning=FALSE}
customers_df %>%
  kbl() %>%
  kable_classic(full_width = F, html_font = "Cambria")
```

<br>

```{r}
customers_df <- dbGetQuery(con, "SELECT * FROM adclicks LIMIT 10")
```

```{r, message=FALSE, warning=FALSE}
customers_df %>%
  kbl() %>%
  kable_classic(full_width = F, html_font = "Cambria")
```

<br>

The `adclicks` table has this information in it:
* the `time` that a webpage was visited (stored as `TEXT` in this `sqlite` table)
* an `adID` that identifies a particular advertisement that was shown to the customer (an `INTEGER`)
* whether or not the ad was `clicked` on by the customer (another `INTEGER`, but in particular, a 0 or 1)
* the `webpageViewed` showing the type of page where the advertisement was displayed (another `TEXT` field)
* the `userID` of the customer in question (an `INTEGER`)

Note that the `userID` in this table is referring to the same `userID` information in the `customers` table.  This column is how we will **join** these two tables together (described later).  

Note also that SQL is case-insensitive and referring to the column `userID` as `userid` or `USERID` (or other variations) will all work to give the same results.  We will refer to the columns using all lowercase versions of the names in what follows.

<br>

## COUNT

---

### COUNT, SUM, and DISTINCT - Let SQL do work for you!

SQL has many functions that can perform calculations and extract summary statistics about the data in tables.  As the name suggests, `COUNT` gives us the number of items (rows) in the query.  In particular, we can use this to find the number of customers in the `customers` table. 


```{r}
customers_df <- dbGetQuery(con, "SELECT COUNT(*) FROM customers")
```

```{r, message=FALSE, warning=FALSE}
customers_df %>%
  kbl() %>%
  kable_classic(full_width = F, html_font = "Cambria")
```

<br>

Strictly speaking, `COUNT(*)` will give us a count of the number of rows where **some** element in that row is not `NULL`.  See the example on the `zipcode` column below.  

```{r}
adclicks_df <- dbGetQuery(con, "SELECT COUNT(*) FROM adclicks")
```

```{r, message=FALSE, warning=FALSE}
adclicks_df %>%
  kbl() %>%
  kable_classic(full_width = F, html_font = "Cambria")
```

<br>

## SUM

---

`SUM` will sum the values in a column.  We specify which column to sum in the `SELECT` statement, and SQL will compute the sum for us.  


```{r}
adclicks_df <- dbGetQuery(con, "SELECT SUM(clicked) FROM adclicks")
```
```{r, message=FALSE, warning=FALSE}
adclicks_df %>%
  kbl() %>%
  kable_classic(full_width = F, html_font = "Cambria")
```

<br>

## SUM

---

Using `SUM` and `COUNT`, we can perform arithmetic calculations.  Note that we have multiplied the numerator in this calculation by 1.0 to get a *floating point* result.  Otherwise SQL will perform *integer division* as both operands are integers in this case (which would result in a value of 0).

```{r}
adclicks_df <- dbGetQuery(con, "SELECT SUM(clicked)*1.0/COUNT(clicked) FROM adclicks")
```

```{r, message=FALSE, warning=FALSE}
adclicks_df %>%
  kbl() %>%
  kable_classic(full_width = F, html_font = "Cambria")
```

<br>

## AS

### Naming Tables with AS

So the basic click-through rate is about 11.5%.  

When we `SELECT` data from a table, we can also **alias** this information using `AS` to do so.  In other words, we can call the result something else.


```{r}
adclicks_df <- dbGetQuery(con, "SELECT SUM(clicked)*1.0/COUNT(clicked) AS click_rate FROM adclicks")
```


```{r, message=FALSE, warning=FALSE}
adclicks_df %>%
  kbl() %>%
  kable_classic(full_width = F, html_font = "Cambria")
```

<br>

## DISTINCT

---

`DISTINCT` is a method that can help to get more information about your data.  This operation gives a list of the unique values in a specified column. 

```{r}
customers_df <- dbGetQuery(con, "SELECT DISTINCT zipcode FROM customers")
```


```{r, message=FALSE, warning=FALSE}
customers_df %>%
  kbl() %>%
  kable_classic(full_width = F, html_font = "Cambria")
```

<br>

**Remark:** Note the value `None` in the list above.  This is the way that `sqlite` denotes a missing value in a row (or one or more rows in which the ZIP code is missing, as we're getting the distinct values in this query).  Strictly speaking, `NULL` is the SQL value that is used for something that is missing.  `NULL` is translated into `None` in the *output* of the query in the Jupyter notebook.  We'll talk more about missing values later in this notebook. 

```{r}
#  Counts distinct non-null(!) entries
customers_df <- dbGetQuery(con, "SELECT COUNT(DISTINCT zipcode) 
AS number_of_zip_codes 
FROM customers")
```


```{r, message=FALSE, warning=FALSE}
customers_df %>%
  kbl() %>%
  kable_classic(full_width = F, html_font = "Cambria")
```

<br>

### A note on SQL "code style"

All of our examples so far have been following the usual SQL conventions on code style.  SQL doesn't care about the case of commands, table names, and column names.  These two SQL commands will give you exactly the same result.

```sql
SELECT COUNT(userID) FROM customers;
select count(userid) from customers;
```

However, the usual convention in SQL code is that commands and operations such as `SELECT` and `COUNT` are capitalized.  As stated earlier, we are referring to the column names in tables using all lowercase letters.  SQL doesn't pay attention to the case of commands or table/column names, but following conventions will make it easier for others to read and understand your SQL code. 

Also, we use the fact that SQL doesn't care about white space to write longer queries over several lines to show the different parts of the query more easily. 

We note that there are many SQL "style guides", and we are taking a relatively simple approach.  We will break long queries across several lines on the FROM clause, the WHERE clause (see the next section), etc.  We'll indent if the SELECT (or FROM, etc) clause would be too long to have on a single line, so that we would break it across several lines. 

Finally, many SQL interpreters are expecting a query to end with a semicolon.  That isn't necessary in this notebook, as the Jupyter extension essentially adds a semicolon for us, but we are putting it there anyway to encourage good coding practice!

<br>

## WHERE

---

### WHERE, LIKE, and IN - Filtering the data

Filtering is selecting a subset of your data that satisfies one or more conditions.  In SQL one way to filter your data is to add a `WHERE` clause to a `SELECT` query.

```{r}
customers_df <- dbGetQuery(con, "SELECT * 
FROM customers 
WHERE age > 50 LIMIT 10")
```


```{r, message=FALSE, warning=FALSE}
customers_df %>%
  kbl() %>%
  kable_classic(full_width = F, html_font = "Cambria")
```

<br>

## WHERE & AND

The `WHERE` clause can use the expected types of operations to select a range of values, such as an inequality statement or to specify that a column must equal a specified value, and selections can be combined together with Boolean operations like `OR`, `AND`, and `NOT`.

```{r}
customers_df <- dbGetQuery(con, "SELECT * 
FROM customers 
WHERE age > 50 AND zipcode = '11715'")
```

```{r, message=FALSE, warning=FALSE}
customers_df %>%
  kbl() %>%
  kable_classic(full_width = F, html_font = "Cambria")
```

<br>

We can, as you might expect, combine filtering with our other previous operations to perform a calculation. 


```{r}
adclicks_df <- dbGetQuery(con, "SELECT SUM(clicked)*1.0/COUNT(clicked) 
AS e_commerce_rate 
FROM adclicks 
WHERE webpageviewed = 'ecommerce'")
```


```{r, message=FALSE, warning=FALSE}
adclicks_df %>%
  kbl() %>%
  kable_classic(full_width = F, html_font = "Cambria")
```

<br>

## LIKE

---

So when customers see advertisements on E-commerce websites the ad click-through rate is lower than the overall average, only about 7.8%. 

`LIKE` can be used to filter data on `TEXT` fields.  We can use `%` as a wildcard character to stand in for zero or more characters.

```{r}
customers_df <- dbGetQuery(con, "SELECT COUNT(*) 
FROM customers 
WHERE zipcode LIKE '06%' AND age > 50")
```


```{r, message=FALSE, warning=FALSE}
customers_df %>%
  kbl() %>%
  kable_classic(full_width = F, html_font = "Cambria")
```

<br>

## IN

---

`IN` lets you specify a set of values for a column, expressed as a parenthesized collection.  

```{r}
customers_df <- dbGetQuery(con, "SELECT * 
FROM customers 
WHERE zipcode IN ('06403', '06267')")
```


```{r, message=FALSE, warning=FALSE}
customers_df %>%
  kbl() %>%
  kable_classic(full_width = F, html_font = "Cambria")
```

<br>

## WHERE NOT

---

We can also negate a clause with `NOT`, though it looks slightly different with the `IN` syntax

```{r}
customers_df <- dbGetQuery(con, "SELECT COUNT(*)
FROM customers
WHERE NOT (zipcode LIKE '06%' AND age > 50)")
```


```{r, message=FALSE, warning=FALSE}
customers_df %>%
  kbl() %>%
  kable_classic(full_width = F, html_font = "Cambria")
```

<br>

## WHERE NOT IN

---

```{r}
customers_df <- dbGetQuery(con, "SELECT COUNT(*)
FROM customers
WHERE zipcode NOT IN ('06403', '06267')")
```


```{r, message=FALSE, warning=FALSE}
customers_df %>%
  kbl() %>%
  kable_classic(full_width = F, html_font = "Cambria")
```

<br>

## ORDER BY

---

### ORDER BY - Sorting your outputs

Adding an `ORDER BY` clause in your statement lets you get the output in sorted order.  Specify a column, or columns, on which to sort.  By default, the sort is done in ascending order.

```{r}
customers_df <- dbGetQuery(con, "SELECT * 
FROM customers 
WHERE zipcode IN ('06403', '06267') 
ORDER BY zipcode")
```


```{r, message=FALSE, warning=FALSE}
customers_df %>%
  kbl() %>%
  kable_classic(full_width = F, html_font = "Cambria")
```

<br>

### Sort by Multiple Columns

```{r}
#  Sort by multiple columns
customers_df <- dbGetQuery(con, "SELECT * 
FROM customers 
WHERE zipcode IN ('06403', '06267') 
ORDER BY zipcode, age")
```


```{r, message=FALSE, warning=FALSE}
customers_df %>%
  kbl() %>%
  kable_classic(full_width = F, html_font = "Cambria")
```

<br>

## ORDER BY - DESC

---

As said, the default `ORDER BY` behavior is to sort items in ascending order.  Use `DESC` (*after* the column name) to sort in descending order for that column. We can also explicitly note we are sorting in ascending order by using `ASC` instead.


```{r}
customers_df <- dbGetQuery(con, "SELECT * 
FROM customers 
WHERE zipcode IN ('06403', '06267') 
ORDER BY zipcode DESC, age DESC")
```


```{r, message=FALSE, warning=FALSE}
customers_df %>%
  kbl() %>%
  kable_classic(full_width = F, html_font = "Cambria")
```

<br>

## GROUPBY

---

### GROUPBY Aggregating Data

Up above, we computed the ad click-through rate for advertisements shown on E-commerce websites.  I might want to repeat this click-through rate calculation for each type of webpage (`ecommerce`, `news`, `search`, and `social`, how can I find these values for `webpageviewed`?).  Doing this "by hand" might not be so difficult when there are only a few different types of webpages, but what if there were many of them?  

SQL provides the `GROUP BY` aggregation feature to group data together based on some categorical feature.  Calculations can then be performed within each portion of the grouped data.  It's easy to get a click-through rate for each of the different values for `webpageviewed` using the `GROUP BY` method.  

SQL `GROUP BY` aggregations are similar in nature to those you have seen in the `pandas` notebooks, but for SQL you always have to supply an aggregation function (unlike in `pandas` where you can create and save group objects and then *later* apply aggregation functions).

```{r}
adclicks_df <- dbGetQuery(con, "SELECT webpageviewed, SUM(clicked)*1.0/COUNT(clicked) AS click_rate 
FROM adclicks 
GROUP BY webpageviewed")
```


```{r, message=FALSE, warning=FALSE}
adclicks_df %>%
  kbl() %>%
  kable_classic(full_width = F, html_font = "Cambria")
```

<br>

## GROUPBY COUNT

---

`GROUP BY` can be used to group your data on more than one category, giving us a finer partition of our original data.  These are the raw numbers that were used in the previous calculation of click-through rates for each webpage group.  Note that we have used an alias for the `COUNT` function values using `AS` to specify the name for the counts. 

```{r}
adclicks_df <- dbGetQuery(con, "SELECT webpageviewed, clicked, COUNT(*) AS counts 
FROM adclicks 
GROUP BY webpageviewed, clicked")
```


```{r, message=FALSE, warning=FALSE}
adclicks_df %>%
  kbl() %>%
  kable_classic(full_width = F, html_font = "Cambria")
```

<br>

## HAVING

---

### HAVING - The "WHERE" clause for grouped data

If we want to filter the data *after* aggregating it, we can supply a `HAVING` clause.  Think of this as similar to `WHERE`, but applied to the grouped data.  

For example, what ZIP codes have 10 or more customers in them?  This is easy to answer by grouping on `zipcode` and adding a `HAVING` clause.  Note that we alias the output of `COUNT` to refer to it in the `HAVING` clause.   

```{r}
customers_df <- dbGetQuery(con, "SELECT zipcode, COUNT(*) AS number 
FROM customers 
GROUP BY zipcode 
HAVING number >= 10")
```


```{r, message=FALSE, warning=FALSE}
customers_df %>%
  kbl() %>%
  kable_classic(full_width = F, html_font = "Cambria")
```

<br>

Which classes of webpages have been seen at least 300 times by the customers?  We'll again use an alias for the `COUNT` we compute to easily refer to the count in the `HAVING` clause.

```{r}
adclicks_df <- dbGetQuery(con, "SELECT webpageviewed, COUNT(*) AS views 
FROM adclicks 
GROUP BY webpageviewed 
HAVING views >= 300")
```


```{r, message=FALSE, warning=FALSE}
adclicks_df %>%
  kbl() %>%
  kable_classic(full_width = F, html_font = "Cambria")
```

<br>

# SQL Syntax

---

## More on SQL Syntax

In general, the SQL syntax for queries (involving a single table) is as follows:

```sql
SELECT <cols> 
FROM <table> 
WHERE <conditions> 
GROUP BY <cols> 
HAVING <conditions> 
ORDER BY <cols> 
LIMIT n;
```
<br>

Some of these parts of the query could be missing, e.g. the `ORDER BY` clause, or the `WHERE` clause.  In certain cases, it's necessary to have a clause, e.g. using `HAVING` necessitates using `GROUP BY` since `HAVING` is specifying conditions on the *grouped data*.

<br>

# JOIN's

---

## JOIN

### JOIN - Putting tables together

The example we have contains two tables, `customers` and `adclicks`.  As was mentioned near the start of the notebook, both tables have a column called `userid`.  This column can be used to **join** the tables together, by matching rows from one table to another where the `userid` values agree.  This can be done is several ways.  One of them is as follows:

```{r}
#  Use two table names in the FROM part
customers_adclicks_df <- dbGetQuery(con, "SELECT * 
FROM customers, adclicks            
WHERE customers.userid = adclicks.userid 
LIMIT 5")
```


```{r, message=FALSE, warning=FALSE}
customers_adclicks_df %>%
  kbl() %>%
  kable_classic(full_width = T, font_size=11, html_font = "Cambria")
```

<br>

Joining the tables in this manner now allows us to determine what webpages that a particular customer saw.  We don't have to look up a particular user in the `customers` table, find their `userid`, and *then* use that to look up the webpage views in the `adclicks` table.  Joining the data in this manner allows us to merge the two sets of data into one.  

Note the use of the prefixes of the table names to refer to the individual column in each corresponding table.  We can specify *how* to join the data using a `WHERE` clause to do this.  If we do the join in this manner, note that we get the repeated column `userid`, one from the `customers` table and again from the `adclicks` table.  

If desired, we can still specify a subset of columns in the `SELECT` statement.  If the column only appears in one table, we don't need to use the table as a prefix to the column name.

```{r}
customers_adclicks_df <- dbGetQuery(con, "SELECT customers.userid, name, time, adid, clicked, webpageviewed 
FROM customers, adclicks
WHERE customers.userid = adclicks.userid 
LIMIT 5")
```


```{r, message=FALSE, warning=FALSE}
customers_adclicks_df %>%
  kbl() %>%
  kable_classic(full_width = F, html_font = "Cambria")
```

<br>

We can add additional clauses to `WHERE` to specify certain people, ranges, etc, as before.  

```{r}
customers_adclicks_df <- dbGetQuery(con, "SELECT customers.userid, name, time, clicked, webpageviewed 
FROM customers, adclicks
WHERE customers.userid = adclicks.userid AND webpageviewed = 'news'
LIMIT 5")
```

```{r, message=FALSE, warning=FALSE}
customers_adclicks_df %>%
  kbl() %>%
  kable_classic(full_width = F, html_font = "Cambria")
```

<br>

There are other ways that we can specify a `JOIN` between tables.  We'll illustrate each method with some examples. 

Another way is to perform a `JOIN` query is to use this type of syntax: `<table1> JOIN <table2> ON <condition>`

```{r}
customers_adclicks_df <- dbGetQuery(con, "SELECT customers.userid, name, time, clicked, webpageviewed 
FROM customers JOIN adclicks ON customers.userid = adclicks.userid 
WHERE webpageviewed = 'news' 
LIMIT 5")
```

```{r, message=FALSE, warning=FALSE}
customers_adclicks_df %>%
  kbl() %>%
  kable_classic(full_width = F, html_font = "Cambria")
```

<br>

As an alternative to the previous case, if there is a column name that is the same in both tables, a `JOIN <table> USING(<column>)` construct can be used.  This query will automatically test for equality between values in the matching column.  


```{r}
customers_adclicks_df <- dbGetQuery(con, "SELECT customers.userid, name, time, clicked, webpageviewed 
FROM customers JOIN adclicks USING(userid) 
WHERE webpageviewed = 'news' 
LIMIT 5")
```

```{r, message=FALSE, warning=FALSE}
customers_adclicks_df %>%
  kbl() %>%
  kable_classic(full_width = F, html_font = "Cambria")
```

<br>

## NATURAL JOIN

---

Assuming that the two tables have one or more pairs of identically named columns, a `JOIN` can also be performed using the `NATURAL JOIN` operation in the query.  Similar to the `USING` construction above, `NATURAL JOIN` automatically tests for equality between the values of every column that exists in both tables.  (The matched columns must be the same data type for the `NATURAL JOIN` to work successfully.)

```{r}
customers_adclicks_df <- dbGetQuery(con, "SELECT * FROM customers 
NATURAL JOIN adclicks 
LIMIT 10")
```

```{r, message=FALSE, warning=FALSE}
customers_adclicks_df %>%
  kbl() %>%
  kable_classic(full_width = T, font_size=11, html_font = "Cambria")
```

<br>

We can still add in `WHERE` clauses using this syntax.  


```{r}
customers_adclicks_df <- dbGetQuery(con, "SELECT customers.userid, name, webpageviewed, 
    ROUND(SUM(clicked)*1.0/COUNT(clicked),3) AS click_rate
    FROM customers NATURAL JOIN adclicks
    WHERE customers.userid = 64 OR customers.userid = 48
    GROUP BY name, webpageviewed")
```

```{r, message=FALSE, warning=FALSE}
customers_adclicks_df %>%
  kbl() %>%
  kable_classic(full_width = F, html_font = "Cambria")
```

<br>

With some judicious querying, we can get click-through rates for individual people for each category of webpage by selecting data and grouping it appropriately. 

```{r}
customers_adclicks_df <- dbGetQuery(con, "SELECT customers.userid, name, webpageviewed, 
    ROUND(SUM(clicked)*1.0/COUNT(clicked),3) AS click_rate
    FROM customers NATURAL JOIN adclicks
    WHERE customers.userid = 64 OR customers.userid = 48
    GROUP BY name, webpageviewed")
```

```{r, message=FALSE, warning=FALSE}
customers_adclicks_df %>%
  kbl() %>%
  kable_classic(full_width = F, html_font = "Cambria")
```

<br>

### A world of `JOIN`s 

Strictly speaking, all of the previous examples of joins would be properly referred to as "inner joins".  This means that only rows that match the join condition are kept, and rows (from either table) that don't match the join condition are eliminated from the result. This hasn't had a meaningful result on our queries so far, since all of the users that clicked on ads are in our database. We can see this by simply checking that all of our clicks show up after the join. 

```{r}
adclicks_df <- dbGetQuery(con, "SELECT COUNT(*) FROM adclicks")
```

```{r, message=FALSE, warning=FALSE}
adclicks_df %>%
  kbl() %>%
  kable_classic(full_width = F, html_font = "Cambria")
```

<br>

```{r}
customers_adclicks_df <- dbGetQuery(con, "SELECT COUNT(*) FROM adclicks JOIN customers 
USING(userid)")
```

```{r, message=FALSE, warning=FALSE}
customers_adclicks_df %>%
  kbl() %>%
  kable_classic(full_width = F, html_font = "Cambria")
```

<br>

However, not all the customers in our database clicked on an ad.

```{r}
customers_adclicks_df <- dbGetQuery(con, "SELECT COUNT(DISTINCT userid) FROM customers")
```

```{r, message=FALSE, warning=FALSE}
customers_adclicks_df %>%
  kbl() %>%
  kable_classic(full_width = F, html_font = "Cambria")
```

<br>

```{r}
customers_adclicks_df <- dbGetQuery(con, "SELECT COUNT(DISTINCT userid) FROM adclicks")
```

```{r, message=FALSE, warning=FALSE}
customers_adclicks_df %>%
  kbl() %>%
  kable_classic(full_width = F, html_font = "Cambria")
```

<br>

### Note on JOIN's

In contrast to "inner joins" there are also "outer joins" where data that doesn't match the join condition is **not eliminated**.  The SQL standard defines three type of `OUTER JOIN` operations, but only one of them is supported by `sqlite`, the `LEFT OUTER JOIN`.  In `LEFT OUTER JOIN`, all the values of the columns you select from the left table will be included in the result of the query, regardless of whether or not any value matches the join condition.  So if the left table has $k$ values in the column you're joining on, the result of the `LEFT OUTER JOIN` will also have $k$ values.  But for the values of columns coming from the right table, if any value doesn't match the join condition it will contain a `NULL` value.  

`RIGHT OUTER JOIN` works similarly, but rows from the right table are not eliminated, and `FULL OUTER JOIN` would keep all rows from both tables.  

In summary, the main differences in these joins is which data is kept, and this will depend upon whether the join is an "inner join" (which eliminates rows that don't match the join condition) or "outer join" (which keeps rows regardless of whether there is a match on the join condition or not), and the data kept also depends upon whether the join is `LEFT`, `RIGHT`, or `FULL`.  As a reminder, `sqlite` only supports `LEFT OUTER JOIN` for outer join operations.  

The differences between the types of joins are illustrated in the figure below.  &lt;how&gt; is one of the words "LEFT", "RIGHT", "INNER", or "OUTER".

<br>

![ex](sql_merge_examples.svg)

<br>

**Remarks:**
* `JOIN` is the same as `INNER JOIN`.  The word `INNER` is optional.  This means only rows that match the join condition are kept and other rows that don't match the join condition are eliminated.  
* The `OUTER` clause is optional.  `LEFT JOIN` is the same as `LEFT OUTER JOIN`, i.e. all rows from the left table will appear in the result.  

In our case, we can see this with our missing customer. Let's only look at customers over $70$ to keep the output small.

```{r}
customers_df <- dbGetQuery(con, "SELECT * FROM customers WHERE age > 70")
```

```{r, message=FALSE, warning=FALSE}
customers_df %>%
  kbl() %>%
  kable_classic(full_width = F, html_font = "Cambria")
```

<br>

```{r}
customers_adclicks_df <- dbGetQuery(con, "SELECT customers.userid, name, age, adid, clicked
FROM customers JOIN adclicks USING(userid)
WHERE age > 70
ORDER BY userid")
```

```{r, message=FALSE, warning=FALSE}
customers_adclicks_df %>%
  kbl() %>%
  kable_classic(full_width = F, html_font = "Cambria")
```

<br>

## LEFT OUTER JOIN

---

We can see that user $55$ isn't present.  If we `LEFT OUTER JOIN`, we'll see them show up with `NULL` values in the rows from `adclicks`.

```{r}
customers_adclicks_df <- dbGetQuery(con, "SELECT customers.userid, name, age, adid, clicked
FROM customers LEFT OUTER JOIN adclicks USING(userid)
WHERE age > 70
ORDER BY userid")
```

```{r, message=FALSE, warning=FALSE}
customers_adclicks_df %>%
  kbl() %>%
  kable_classic(full_width = F, html_font = "Cambria")
```

<br>

And if we reverse the order, so we have `adclicks` on the left of the join, user $55$ will be gone again.

```{r}
customers_adclicks_df <- dbGetQuery(con, "SELECT customers.userid, name, age, adid, clicked
FROM adclicks LEFT OUTER JOIN customers USING(userid)
WHERE age > 70
ORDER BY userid")
```

```{r, message=FALSE, warning=FALSE}
customers_adclicks_df %>%
  kbl() %>%
  kable_classic(full_width = F, html_font = "Cambria")
```

<br>

# Subqueries

---

## Creating and using subqueries 

When writing complex SQL queries, it can be beneficial to use one (or more) "subqueries", i.e. a query nested inside of a larger query.  As might be imagined, there are several ways that this can be done.  It is often useful to build up the a complex query by looking at component queries.  

First consider this query that finds the first time that a customer viewed a webpage as recorded in our given data.

```{r}
customers_adclicks_df <- dbGetQuery(con, "SELECT userid, MIN(time) AS first_view 
FROM customers JOIN adclicks USING(userid) 
GROUP BY userid LIMIT 5")
```

```{r, message=FALSE, warning=FALSE}
customers_adclicks_df %>%
  kbl() %>%
  kable_classic(full_width = F, html_font = "Cambria")
```

<br>

Now we can use this as a subquery to make a larger query.  Suppose that we want to get all of the information about this "first view" of each customer.  One way to create a subquery is to use a `WITH` statement where we create a table and use an alias for the whole table.  

Note how we "knit" the three tables together by matching `customers` and `adclicks`, then matching the `time` from `adclicks` with the `first_view` column in the aliased table.  This will give us
one row for each person in the customer database.  (Assuming that there is no missing data in the `userid` or `time` columns.) 

```{r}
customers_adclicks_df <- dbGetQuery(con, "WITH first_views AS 
    (SELECT userid, MIN(time) AS first_view 
    FROM customers JOIN adclicks USING(userid) 
    GROUP BY userid)
SELECT * 
FROM customers, adclicks, first_views 
WHERE customers.userid = adclicks.userid AND adclicks.time = first_view
LIMIT 10")
```

```{r, message=FALSE, warning=FALSE}
customers_adclicks_df <- customers_adclicks_df %>% 
  select(1:8, 11)

customers_adclicks_df %>%
  kbl() %>%
  kable_classic(full_width = T, font_size=11, html_font = "Cambria")
```

<br>

We have repeated columns in our output, so we could naturally clean this result to show only the columns we want. 

```{r}
customers_adclicks_df <- dbGetQuery(con, "WITH first_views AS 
    (SELECT userid, MIN(time) AS first_view 
    FROM customers JOIN adclicks USING(userid) 
    GROUP BY userid)
SELECT customers.userid, name, zipcode, age, first_view, adid, clicked, webpageviewed 
FROM customers, adclicks, first_views 
WHERE customers.userid = adclicks.userid AND adclicks.time = first_view
LIMIT 10")
```

```{r, message=FALSE, warning=FALSE}
customers_adclicks_df %>%
  kbl() %>%
  kable_classic(full_width = F, font_size=11, html_font = "Cambria")
```

<br>

Finally, with some grouping of the data, and our friendly `SUM` and `COUNT` functions, we can get the click-through rate for each of the `adid` values based on the **first ad viewings** by our customers. 

```{r}
customers_adclicks_df <- dbGetQuery(con, "WITH first_views AS 
    (SELECT userid, MIN(time) AS first_view 
    FROM customers JOIN adclicks USING(userid) 
    GROUP BY userid)
SELECT customers.userid, name, zipcode, age, first_view, adid, clicked, webpageviewed 
FROM customers, adclicks, first_views 
WHERE customers.userid = adclicks.userid AND adclicks.time = first_view
LIMIT 10")
```

```{r, message=FALSE, warning=FALSE}
customers_adclicks_df %>%
  kbl() %>%
  kable_classic(full_width = F, font_size=11, html_font = "Cambria")
```

<br>

A `WITH` clause, aliasing the result, is one way to utilize a subquery.  We could put the subquery directly into the other query, as shown in the example below.  This query gives the exact same result, but is an alternative way to express the query.  Note how we essentially inserted the subquery in place of the `first_views` alias in the previous query.  Which method you use is entirely up to you, but use one that seems more natural or clear to you (or your coding collaborators).  


```{r}
customers_adclicks_df <- dbGetQuery(con, "SELECT adid, ROUND(SUM(clicked)*1.0/COUNT(*),3) AS first_view_click_rate
FROM customers, adclicks, 
    (SELECT userid, MIN(time) AS first_view 
    FROM customers JOIN adclicks USING(userid) 
    GROUP BY userid)
WHERE customers.userid = adclicks.userid AND adclicks.time = first_view
GROUP BY adid")
```

```{r, message=FALSE, warning=FALSE}
customers_adclicks_df %>%
  kbl() %>%
  kable_classic(full_width = F, html_font = "Cambria")
```

<br>

# CASE

---

## CASE - Returning values based on conditional statements

There are times when we might want to generate *new* values from our data, based on conditional statements applied to the data in a table.  In our use case, it is probably of little use to the marketing department to examine ad click-through rates for a specific value of `age`, e.g. for people who are 49 years old.  From a marketing perspective, it is more likely that grouping together customers having similar ages will be more informative, as well as aligning with standard marketing practices such as targeting a specific age group with advertising that will be more "relevant" to people in that age group.  

Using a `CASE` construction in SQL allows us to return a new value based on specified conditions.  We can use a `CASE` statement in `SELECT` queries, as well as `WHERE` statements, and `ORDER BY` and `GROUP BY` clauses.  

Consider this first example where we are generating a categorical variable based on a customer's `age`.  We generate a new `age_bracket` column in the resulting table by checking the value of `age` and returning a new value.  

We have deliberately selected only three columns in our result to illustrate the result of the `CASE` statement.

```{r}
customers_adclicks_df <- dbGetQuery(con, "SELECT userid AS uid, age,
    CASE
        WHEN  0 <= age AND age < 13 THEN 'young'
        WHEN 13 <= age AND age <= 19 THEN 'teens'
        WHEN 20 <= age AND age < 30 THEN '20s'
        WHEN 30 <= age AND age < 40 THEN '30s'
        WHEN 40 <= age AND age < 50 THEN '40s'
        WHEN 50 <= age AND age < 60 THEN '50s'
        WHEN 60 <= age AND age < 70 THEN '60s'
        WHEN 70 <= age THEN 'seniors'
        ELSE 'other'
    END AS age_bracket 
FROM customers
LIMIT 10")
```

```{r, message=FALSE, warning=FALSE}
customers_adclicks_df %>%
  kbl() %>%
  kable_classic(full_width = F, html_font = "Cambria")
```

<br>

We note that there are some missing values in the table (we see at least one `None` output above).  With a closer look, we can find some other dubious `age` values.  At least one person is allegedly 5 years old, and we can find there is one person with a reported age that is negative.

```{r}
customers_adclicks_df <- dbGetQuery(con, "SELECT userid, age FROM customers 
WHERE age < 10 OR age IS NULL 
ORDER BY age")
```

```{r, message=FALSE, warning=FALSE}
customers_adclicks_df %>%
  kbl() %>%
  kable_classic(full_width = F, html_font = "Cambria")
```

<br>

We aren't doing anything to deal with these missing/dubious values in our analysis, but handling missing data in an appropriate fashion is an important skill for any data scientist to cultivate.  We are putting together these "outliers" into one group in what follows, by using the `CASE` statement we gave above.  

Now using the output of the `CASE` statement as a subquery, we can group the customers together in age bands and find click-through rates for each age band.

```{r}
customers_adclicks_df <- dbGetQuery(con, "WITH brackets AS 
    (SELECT userid AS uid, 
    CASE
        WHEN  0 <= age AND age < 13 THEN 'young'
        WHEN 13 <= age AND age <= 19 THEN 'teens'
        WHEN 20 <= age AND age < 30 THEN '20s'
        WHEN 30 <= age AND age < 40 THEN '30s'
        WHEN 40 <= age AND age < 50 THEN '40s'
        WHEN 50 <= age AND age < 60 THEN '50s'
        WHEN 60 <= age AND age < 70 THEN '60s'
        WHEN 70 <= age THEN 'seniors'
        ELSE 'other'
    END AS age_bracket 
    FROM customers)
SELECT age_bracket, 
    ROUND(SUM(clicked)*1.0/COUNT(clicked),3) AS click_rate, 
    COUNT(clicked) AS number_of_ad_views
FROM customers, brackets, adclicks 
WHERE customers.userid = uid AND adclicks.userid = uid
GROUP BY age_bracket 
ORDER BY age_bracket")
```

```{r, message=FALSE, warning=FALSE}
customers_adclicks_df %>%
  kbl() %>%
  kable_classic(full_width = F, html_font = "Cambria")
```

<br>

A similar query lets us find click-through rates for different age group/`adid` combinations.  Maybe different advertisements are more effective with different age groups?  But here we start to run into problems with the sample sizes.  Small groups don't really lend themselves well to sound statistical conclusions.  

```{r}
customers_adclicks_df <- dbGetQuery(con, "WITH brackets AS 
    (SELECT userid AS uid, 
    CASE
        WHEN  0 <= age AND age < 13 THEN 'young'
        WHEN 13 <= age AND age <= 19 THEN 'teens'
        WHEN 20 <= age AND age < 30 THEN '20s'
        WHEN 30 <= age AND age < 40 THEN '30s'
        WHEN 40 <= age AND age < 50 THEN '40s'
        WHEN 50 <= age AND age < 60 THEN '50s'
        WHEN 60 <= age AND age < 70 THEN '60s'
        WHEN 70 <= age THEN 'seniors'
        ELSE 'other'
    END AS age_bracket 
    FROM customers)
SELECT adid, age_bracket, 
    ROUND(SUM(clicked)*1.0/COUNT(clicked),3) AS click_rate, 
    COUNT(clicked) AS number_of_ad_views
FROM customers, brackets, adclicks 
WHERE customers.userid = uid AND adclicks.userid = uid
GROUP BY adid, age_bracket 
ORDER BY adid, age_bracket
LIMIT 10")
```

```{r, message=FALSE, warning=FALSE}
customers_adclicks_df %>%
  kbl() %>%
  kable_classic(full_width = F, html_font = "Cambria")
```

<br>

Note that in this case, we could group our data into age brackets in a simpler way, by dividing `age` by ten, keeping the dividend, and discarding the remainder, then grouping on that resulting value.  This will group, for example, people who are ages 24 and 27 into the same age band.  

This still leaves us with the issue of the missing data to deal with, but we could use a `CASE` statement to impute a value in those cases, provided we come up with a reasonable value to use there.

```{r}
customers_adclicks_df <- dbGetQuery(con, "SELECT age/10 AS decades_old, 
    ROUND(SUM(clicked)*1.0/COUNT(clicked),3) AS click_rate, 
    COUNT(clicked) AS number_of_ad_views
FROM customers, adclicks 
WHERE customers.userid = adclicks.userid
GROUP BY decades_old 
ORDER BY decades_old")
```

```{r, message=FALSE, warning=FALSE}
customers_adclicks_df %>%
  kbl() %>%
  kable_classic(full_width = F, html_font = "Cambria")
```

<br>

```{r}
# Close the database connection to CarsDB
dbDisconnect(con)
```

<div class="tocify-extend-page" data-unique="tocify-extend-page" style="height: 0;"></div>
