---
title: "SQL with R"
author: "Kyle W. Brown"
date: "2/21/2021"
output:
  pdf_document:
    toc: yes
    toc_depth: '2'
  html_document:
    fig_caption: no
    theme: readable
    toc: yes
    toc_depth: 2
    toc_float:
      collapsed: yes
  word_document:
    toc: yes
    toc_depth: '2'
editor_options: 
  chunk_output_type: inline
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
library(dplyr)
library(dbplyr)
library(kableExtra)
library(reactable)
```

<br>

# Intro

## Using SQL with R

This document demonstrate the power of R with SQL. There is several different ways to perform SQL queries with RStudio. Here there are four ways of performing SQL queries.  


# DB Connection

---

## Create In-Memory SQLite Database

```{r, echo=TRUE}
conn <- src_memdb()
```

## Copy Data to DB Connection

```{r, echo=TRUE}
copy_to(conn, 
        storms, # dplyr dataset
        overwrite = TRUE)
```

<br>

# Tables

---

## Viewing Tables

View SQL tables three different methods in R. The first looking directly at the connection. The second stores the SQL into a R `data.frame`. The third reads the query directly from calling SQL vignette in R markdown chuck options.  

## First Method

Calling the `tbl()` directly with the SQL query. 

```{r}
tbl(conn, sql("SELECT * 
               FROM storms
               LIMIT 5"))
```

<br>

## Second Method

SQL query directly from the connection options in the SQL vignette. 

Note: this method causes the html page to distort upon adding table of contents to the yaml. 

### In-Memory Storage

```{r}
con <- src_memdb()$con
```

## Fourth Method

#### Query from In-Memory Connection 

```{sql connection=con}
SELECT * 
FROM storms 
LIMIT 5;
```

<br>

### Fourth Method

Viewing the table from the chunk options only.


#### Adding Hurricane Status to Table

Inserting `Status` with R and storing a field variable "hurricane" in an R object.

```{r}
storm_status <- "hurricane"
```

#### **Using SQL Connection Chunk Options**

When running queries and using SQL directly we set the chunk options to ` ```{sql connection=con}`. The connection reads our original connection with Storms dataset. 

```{sql connection=con}
SELECT * 
FROM storms 
WHERE status = ?storm_status 
LIMIT 5;
```

<br>

### Using `glue()`

Here `glue()` is used to insert the column name status of hurricane into the dataset. 

```{r}
col_name <- glue::glue_sql("status")
```

```{sql connection=con}
SELECT * 
FROM storms 
WHERE ?col_name = 'hurricane' 
LIMIT 5;
```

<br>

```{r}
types <- c("hurricane", "tropical depression")

# without an asterisk
glue::glue_sql("{types}", .con = con)
```

<br>

```{r}
# with an asterisk
glue::glue_sql("{types*}", .con = con)
```

<br>

```{r}
types <- c("hurricane", "tropical depression")
storm_status <- glue::glue_sql("{types*}", .con = con)

storm_status
```

<br>

### Querying the `glue` Insertion Update

```{sql connection=con}
SELECT * 
FROM storms 
WHERE status 
IN (?storm_status) 
LIMIT 5;
```

<br>

### Using Chunk Only

```{sql connection=con, echo=TRUE, code=readLines("storm.sql")}
```

<br>

# RSQLite 

---

RSQLite and the `mtcats` dataset.


```{r}
# Load the RSQLite Library
library(RSQLite)

# Load the mtcars as an R data frame put the row names as a column, and print the header.
data("mtcars")

mtcars$car_names <- rownames(mtcars)
rownames(mtcars) <- c()
```

```{r, echo=FALSE, message=FALSE, warning=FALSE}
mtcars %>%
  kbl() %>%
  kable_classic(full_width = F, html_font = "Cambria")
```

<br>

# New DB Connection

---

## Connection from `.db` File

Create a connection to our new database, CarsDB.db.

You can check that the .db file has been created on your working directory.

```{r}
conn <- dbConnect(RSQLite::SQLite(), "CarsDB.db")
```

<br>

# Write Databases

---

## Write a`.db` into Table

Write the mtcars dataset into a table names mtcars_data.


### Write Table to Connection

Use `dbWriteTable()` to insert the `.db` into the RSQLite connection

```r
# Write table from database 
dbWriteTable(conn, "cars_data", mtcars)
```

```{r}
# List all the tables available in the database
mtcars_df <- dbListTables(conn)
```

```{r, echo=FALSE, message=FALSE, warning=FALSE}
mtcars_df %>%
  kbl() %>%
  kable_classic(full_width = F, html_font = "Cambria")
```

<br>

## Create Dummy Data Frames

```{r}
car <- c('Camaro', 'California', 'Mustang', 'Explorer')
make <- c('Chevrolet','Ferrari','Ford','Ford')
df1 <- data.frame(car,make)

car <- c('Corolla', 'Lancer', 'Sportage', 'XE')
make <- c('Toyota','Mitsubishi','Kia','Jaguar')
df2 <- data.frame(car,make)

# Add them to a list
dfList <- list(df1,df2)

# Write a table by appending the data frames inside the list
for(k in 1:length(dfList)){
    dbWriteTable(conn,"Cars_and_Makes", 
                 dfList[[k]], 
                 append = TRUE)
}

# List all the Tables
mtcars_df <- dbListTables(conn)
```



```{r, echo=FALSE, message=FALSE, warning=FALSE}
mtcars_df %>%
  kbl() %>%
  kable_classic(full_width = F, html_font = "Cambria")
```

<br>

# Queries

---

## Selecting from `Cars_and_Makes` Table

```{r}
mtcars_df <- dbGetQuery(conn, "SELECT * 
                               FROM Cars_and_Makes
                               LIMIT 10")
```

```{r, echo=FALSE, message=FALSE, warning=FALSE}
mtcars_df %>%
  kbl() %>%
  kable_classic(full_width = F, html_font = "Cambria")
```

<br>

## First 10 Rows

Gather the first 10 rows in the cars_data table.

```{r}
mtcars_df <- dbGetQuery(conn, "SELECT * 
                               FROM cars_data 
                               LIMIT 10")
```

```{r, echo=FALSE, message=FALSE, warning=FALSE}
mtcars_df %>%
  kbl() %>%
  kable_classic(full_width = T, html_font = "Cambria")
```

<br>

## 8 Horsepowers Only

Get the car names and horsepower of the cars with 8 cylinders.

```{r}
mtcars_df <- dbGetQuery(conn,"SELECT car_names, hp, cyl 
                              FROM cars_data      
                              WHERE cyl = 8")
```

```{r, echo=FALSE, message=FALSE, warning=FALSE}
mtcars_df %>%
  kbl() %>%
  kable_classic(full_width = F, html_font = "Cambria")
```

<br>

## Filtering by Names/Horsepower and Cylinders

Get the car names and horsepower starting with M that have 6 or 8 cylinders.

```{r}
mtcars_df <- dbGetQuery(conn,"SELECT car_names, hp, cyl
                              FROM cars_data
                              WHERE car_names 
                              LIKE 'M%' 
                              AND cyl 
                              IN (6,8)")
```

```{r, echo=FALSE, message=FALSE, warning=FALSE}
mtcars_df %>%
  kbl() %>%
  kable_classic(full_width = F, html_font = "Cambria")
```

<br>

## Avg Horsepower and mpg by Cylinders

Get the average horsepower and mpg by number of cylinder groups.

```{r}
mtcars_df <- dbGetQuery(conn,"SELECT cyl, AVG(hp) AS 'average_hp', AVG(mpg) AS 'average_mpg' 
                              FROM cars_data
                              GROUP BY cyl
                              ORDER BY average_hp")
```

```{r, echo=FALSE, message=FALSE, warning=FALSE}
mtcars_df %>%
  kbl() %>%
  kable_classic(full_width = F, html_font = "Cambria")
```

<br>

```{r}
avg_HpCyl <- dbGetQuery(conn,"SELECT cyl, AVG(hp) AS 'average_hp'
                              FROM cars_data
                              GROUP BY cyl
                              ORDER BY average_hp")
class(avg_HpCyl)
```


```{r, echo=FALSE, message=FALSE, warning=FALSE}
avg_HpCyl %>%
  kbl() %>%
  kable_classic(full_width = F, html_font = "Cambria")
```

<br>

## >18 mpg with >6 Cylinders

Assuming that there is some user input that asks us to look only into cars that have over 18 miles per gallon (mpg) and more than 6 cylinders.

```{r}
mpg <-  18
cyl <- 6
Result <- dbGetQuery(conn, 'SELECT car_names, mpg, cyl 
                            FROM cars_data 
                            WHERE mpg >= ? 
                            AND cyl >= ?', 
                            params = c(mpg,cyl))
```

```r
Result
```

```{r, echo=FALSE, message=FALSE, warning=FALSE}
Result %>%
  kbl() %>%
  kable_classic(full_width = F, html_font = "Cambria")
```

<br>

# Functions with Queries

---

Assemble an example function that takes the SQLite database connection, a base query, and the parameters you want to use in the WHERE clause as a list.

```{r}
assembleQuery <- function(conn, base, search_parameters){
    parameter_names <- names(search_parameters)
    partial_queries <- ""
    # Iterate over all the parameters to 
    #assemble the query
    for(k in 1:length(parameter_names)){
        filter_k <- paste(parameter_names[k], 
                          " >= ? ")
        # If there is more than 1 parameter, add an AND statement before the 
        # parameter name and placeholder
        if(k > 1){
            filter_k <- paste("AND ", 
                              parameter_names[k], 
                              " >= ?")
        }
        partial_queries <- paste(partial_queries, 
                                 filter_k)
    }
    # Paste all together into a single query using a WHERE statement
    final_paste <- paste(base, " WHERE", 
                         partial_queries)
    
    # Print the assembled query to show how it looks like
    print(final_paste)
    # Run the final query. I unlist the values from the search_parameters list 
    # into a vector since it is needed when using various anonymous placeholders (i.e. >= ?)
    values <- unlist(search_parameters, 
                     use.names = FALSE)
    
    result <- dbGetQuery(conn, final_paste,
                         params = values)
    # return the executed query
    return(result)
}

base <- "SELECT car_names, mpg, hp, wt 
         FROM cars_data"

search_parameters <- list("mpg" = 16, 
                          "hp" = 150, 
                          "wt" = 2.1)

result <- assembleQuery(conn, 
                        base, 
                        search_parameters)
```

```r
result
```

```{r, echo=FALSE, message=FALSE, warning=FALSE}
result %>%
  kbl() %>%
  kable_classic(full_width = F, html_font = "Cambria")
```

<br>

# Delection

---

#### Prior Deletion

Visualize the table before deletion. Selecting everything from the cars_data table. 

```{r}
mtcars_df <- dbGetQuery(conn, "SELECT * 
                               FROM cars_data 
                               LIMIT 10")
```

```{r, echo=FALSE, message=FALSE, warning=FALSE}
mtcars_df %>%
  kbl() %>%
  kable_classic(full_width = F, html_font = "Cambria")
```

<br>

## Delete Mazda Column

Delete the column belonging to the Mazda RX4. You will see a 1 as the output.

```{r}
dbExecute(conn, "DELETE FROM cars_data 
                 WHERE car_names = 'Mazda RX4'")
```

<br>

### Inspect Table after Deletion 

Visualize the new table after deletion

```{r}
mtcars_df <- dbGetQuery(conn, "SELECT * 
                               FROM cars_data
                               LIMIT 10")
```

```{r, echo=FALSE, message=FALSE, warning=FALSE}
mtcars_df %>%
  kbl() %>%
  kable_classic(full_width = F, html_font = "Cambria")
```

<br>

## Insert Mazda RX4 Back

Insert the data for the Mazda RX4. This will also ouput a 1.

```{r}
dbExecute(conn, "INSERT INTO cars_data 
                 VALUES (21.0,6,160.0,110,3.90,2.620,16.46,0,1,4,4,'Mazda RX4')")
```

<br>

### Inspect Results

See that we re-introduced the Mazda RX4 succesfully at the end

```{r}
mtcars_df <- dbGetQuery(conn, "SELECT * 
                               FROM cars_data")
```

```{r, echo=FALSE, message=FALSE, warning=FALSE}
mtcars_df %>%
  kbl() %>%
  kable_classic(full_width = F, html_font = "Cambria")
```

<br>

Close the database connection to CarsDB

```{r}
dbDisconnect(conn)
```

<br>


![](wcis.png){width=40px} &nbsp; ![](bar.png){width=15px} &nbsp; Copyright: &#169; 2021  Kyle W. Brown. All rights reserves.

<div class="tocify-extend-page" data-unique="tocify-extend-page" style="height: 0;"></div>
